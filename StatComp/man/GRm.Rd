% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GRm.R
\name{GRm}
\alias{GRm}
\title{Monitor convergence of a M-H chain by Gelman-Rubin method.}
\usage{
GRm(M, f, burn, graphic = FALSE)
}
\arguments{
\item{M}{a matrix with k(nrow) chains and each chain have length n(ncol).}

\item{f}{the method to compute the scalar summary statistic that estimate some parameters of target distribution. The argument of f should be a numeric vector.}

\item{burn}{burn-in time of the chain.}

\item{graphic}{logical; FALSE is default. If TRUE, show the plot of Gelman-Rubin statistic sequence.}
}
\value{
a numeric value of Gelman-Rubin statistic.
}
\description{
\code{GRm} use Gelman-Rubin method, which is based on comparing the behavior of several generated chains with respect to the variance of one or more scalar summary statistics. The
es- timates of the variance of the statistic are analogous to estimates based on between-sample and within-sample mean squared errors in a one-way analysis of variance(ANOVA).
}
\examples{

\dontrun{
## normal.chain is a funtion to generate M-H chain.
normal.chain = function(w, N, X1) {
x = rep(0, N)
x[1] = X1
prob <- function(y, a) {
  if (y < 0 || y >= w) return (0)
  return((0.5 + y/4)^a[1] * ((1-y)/4)^a[2] * ((1-y)/4)^a[3] * (y/4)^a[4])
}
for (i in 2:N) {
  u = runif(1)
  y = runif(1, 0, w)
  if(u < prob(y, type)/prob(x[i-1], type)) x[i] = y/w
  else x[i] = x[i-1]
}
return(x)
}

X = matrix(0, nrow=k, ncol=n)

## x0 is the vector of initial values with length k.
for (i in 1:k) X[i, ] = normal.chain(w, n, x0[i])

GRm(X, mean, burn) ## mean represents the \\emph{mean} funciton.

GRm(X, mean, burn, graphic = T) ## plot G-R statistic sequence at the same time.
}

}
